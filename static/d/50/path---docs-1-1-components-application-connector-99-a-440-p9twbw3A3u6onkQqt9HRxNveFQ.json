{"pageContext":{"version":"1.1","versions":{"releases":["1.0","0.9","0.8","0.7","0.6","0.5","0.4"],"prereleases":["1.1"],"branches":["master"]},"content":{"id":"application-connector","displayName":"Application Connector","description":"Overall documentation for Application Connector","type":"components","docs":[{"order":"01-01-application-connector","title":"Overview","source":"\nThe Application Connector (AC) is a proprietary Kyma implementation that allows you to connect with external solutions. No matter if you want to integrate an on-premise or a cloud system, the integration process doesn't change, which allows to avoid any configuration or network-related problems.\n\nThe external solution you connect to Kyma using the AC is represented as an Application (App). There is always a one-to-one relationship between a connected solution and an App, which helps to ensure the highest level of security and separation. This means that you must create five separate Apps in your cluster to connect five different external solutions and use their APIs and Event catalogs in Kyma.\n\nThe AC gives you this functionality:\n\n- Manages the lifecycle of Apps.\n- Establishes a secure connection and generates the client certificate used by the connected external solution.\n- Registers the APIs and the Event catalogs of the connected external solution.\n- Delivers the Events from the connected external solution to the Kyma Event Bus.\n- Proxies calls sent from Kyma to external APIs registered by the connected external solution.\n- Allows to map an App to a Kyma Namespace and use its registered APIs and Event catalogs in the context of that Namespace.\n- Integrates the registered APIs and Event catalogs with the Kyma Service Catalog.\n\nAll of the AC components scale independently, which allows to adjust it to fit the needs of the implementation built using Kyma.\n\n>**NOTE:** To learn more about the concept of Namespaces in Kyma, read [this](/docs/1.1/root/kyma#details-namespaces) document.\n\n## Supported APIs\n\nThe Application Connector allows you to register secured REST APIs exposed by the connected external solution. The Application Connector supports a variety of authentication methods to ensure smooth integration with a wide range of APIs. \n\nYou can register an API secured with one of the following authentication methods:\n\n- Basic Authentication\n- OAuth\n- Client Certificates\n\n> **NOTE:** You can register non-secured APIs for testing purposes, however, it is not recommended in the production environment.\n\nIn addition to authentication methods, the Application Connector supports Cross-Site Request Forgery Tokens.\n\nYou can register any API that adheres to the REST principles and is available over the HTTP protocol. The Application Connector also allows you to register APIs implemented with the OData technology. \n\nYou can provide specifications that document your APIs. The Application Connector supports [OpenAPI](https://www.openapis.org/) and [OData](https://www.odata.org/documentation) specification formats."},{"order":"02-01-application-connector","title":"Application Connector components","source":"\n![Architecture Diagram](./assets/001-application-connector.svg)\n\n\n## Nginx Ingress Controller\n\nThe Nginx Ingress Controller exposes the Application Connector by assigning a public IP address and a DNS name to it.\nThe DNS name of the Ingress is cluster-dependant and follows the `gateway.{cluster-dns}` format, for example `gateway.servicemanager.cluster.kyma.cx`.\nYou can access every exposed Application (App) through its gateway by using the assigned path. For example, to reach the gateway for the `user-custom` App, use this URL: `gateway.servicemanager.cluster.kyma.cx/user-custom`. The Nginx Ingress Controller secures the endpoint with certificate validation. Each call must include a valid client certificate which is App-specific.\n\n## Connector Service\n\nThe Connector Service:\n- Handles the exchange of client certificates for a given App.\n- Provides the Application Registry and Event Service endpoints.\n- Signs client certificates using the server-side certificate stored in a Kubernetes Secret.\n\n## Application Registry\n\nThe Application Registry saves and reads the APIs and Event Catalog metadata of the connected external solution in the [Application](#custom-resource-application) custom resource.\nThe system creates a new Kubernetes service for each registered API.\n\n>**NOTE:** Using the Application Registry, you can register an API along with its OAuth or Basic Authentication credentials. The credentials are stored in a Kubernetes Secret.\n\n## Event Service\n\nThe Event Service sends Events to the Kyma Event Bus and enriches the Events with metadata that indicates the source of the Event.\nThis allows routing the Events to lambda functions and services based on their source App.\n\n## Application\n\nAn App represents an external solution connected to Kyma. It handles the integration with other components, such as the Service Catalog or the Event Bus.\nUsing the components of the Application Connector, the App creates a coherent identity for a connected external solution and ensures its separation.\nAll Apps are created through the Application custom resource, which also stores all of the relevant metadata. You can map an App to many Kyma Namespaces and use the APIs and the Event Catalogs of the connected external solution within their context.\n\n## Application Broker\n\nThe Application Broker (AB) watches all [Application](#custom-resource-application) custom resources. These custom resources contain definitions of the external solutions’ APIs and Events. The AB exposes those APIs and Events definitions as ServiceClasses to the Service Catalog. When the list of remote ServiceClasses is available in the Service Catalog, you can create an ApplicationMapping, provision those ServiceClasses, and enable them for Kyma services. This allows you to extend the functionality of existing systems.\n\nThe AB implements the [Open Service Broker API](https://www.openservicebrokerapi.org/). For more details about Service Brokers, see [this](/docs/1.1/components/service-catalog#service-brokers-service-brokers) documentation.\n\n## Application Operator\n\nThe operator listens for creating or deleting the Application custom resources and acts accordingly, either provisioning or de-provisioning an instance of Application Gateway and Event Service for every custom resource.         \n\n>**NOTE:** Every Application custom resource corresponds to a single App to which you can connect an external solution.\n\n## Application Gateway\n\nThe Application Gateway is an intermediary component between a lambda function or a service and an external API registered with the Application Registry. It can call services secured with:\n- [Basic Authentication](https://tools.ietf.org/html/rfc7617) mechanism,\n- OAuth\n- Client certificates\n\nAdditionally, the Application Gateway supports cross-site request forgery (CSRF) tokens as an optional layer of API protection. \n\n## Access Service\n\nThe Access Service exposes the Application Gateway and manages the access from the Lambda functions and services deployed in Kyma to the external APIs over the Application Gateway.\n\n## Asset Store\n\nThe Asset Store stores the documentation of the connected external solution's registered APIs and Event catalogs.\n\n## Kubernetes Secret\n\nThe Kubernetes Secret is a Kubernetes object which stores sensitive data, such as the OAuth credentials.\n","type":"Architecture"},{"order":"02-02-connector-service","title":"Connector Service","source":"\nThe Connector Service generates client certificates which are used to secure the communication between Kyma and the connected external solutions.        \n\nGenerating a new client certificate is the first step in the process of configuring an Application (App). Kyma stores the root certificate and serves as the Certificate Authority when you configure a new App. When you generate a new client certificate, the Connector Service returns it along with the root certificate to allow validation.  \n\nThis diagram illustrates the client certificate generation flow in details:\n![Client certificate generation operation flow](./assets/002-automatic-configuration.svg)\n\n1. The administrator requests for a token using the CLI or the UI and receives a link with the token, which is valid for a limited period of time.\n2. The administrator passes the token to the external system, which requests for information regarding the Kyma installation. In the response, it receives the following information:\n    - the URL to which a third-party solution sends its Certificate Signing Request (CSR)\n    - the URL of the `metadata` endpoint\n    - information required to generate a CSR\n3. The external system generates a CSR based on the information provided by Kyma and sends the CSR to the designated URL. In the response, the external system receives a signed certificate. It can use the certificate to authenticate and safely communicate with Kyma.\n4. The external system calls the `metadata` endpoint that contains the following information:\n    - the URL of the Application Registry API\n    - the URL of the Event Service API\n    - the certificate renewal URL used to rotate certificates\n    - the certificate revocation URL used to revoke compromised certificates\n    - information uniquely identifying certificate, such as the Application name\n    - information required to generate a CSR  \n\n>**NOTE:** The external application should not hardcode any URLs. The information returned from the `metadata` endpoint should be stored by the external application along with the certificate. This approach implicates less coupling and offers a great deal of flexibility. \n\n>**NOTE:**  The external application can call the `metadata` endpoint to fetch information required to generate a CSR prior to certificate renewal. This approach makes certificate rotation process convenient and flexible, since the external application does not need to store information required to generate a CSR in its data model.     \n\n>**NOTE:** Follow [this](#tutorials-get-the-client-certificate) tutorial to learn how to get a client certificate for your implementation.\n","type":"Architecture"},{"order":"02-03-proxy-service","title":"Application Gateway","source":"\nThe Application Gateway sends the requests from Lambda functions and services in Kyma to external APIs registered with the Application Registry. The Application Gateway works in conjunction with the Access Service, which exposes the Application Gateway.\n\n>**NOTE:** The system creates an Access Service for every external API registered by the Application Registry.\n\nThe following diagram illustrates how the Application Gateway interacts with other components and external APIs\nwhich are either unsecured or secured with various security mechanisms and protected against cross-site request forgery (CSRF) attacks.\n\n![Application Gateway Diagram](./assets/003-architecture-proxy-service.svg)\n\n1. A lambda function calls the Access Service. The name of every Access Service follows this format: `app-{application-name}-{service-id}`\n2. The Access Service exposes the Application Gateway.\n3. The Application Gateway extracts the Application name and the service ID from the name of the Access Service name. Using the extracted Application name, the Application Gateway finds the respective Application custom resource and obtains the information about the registered external API, such as the API URL and security credentials.\n4. The Application Gateway gets a token from the OAuth server.\n5. The Application Gateway gets a CSRF token from the endpoint exposed by the upstream service. This step is optional and is valid only for the API which was registered with a CSRF token turned on.\n6. The Application Gateway calls the target API.\n\n## Caching\n\nTo ensure optimal performance, the Application Gateway caches the OAuth tokens and CSRF tokens it obtains. If the service doesn't find valid tokens for the call it makes, it gets new tokens from the OAuth server and the CSRF token endpoint.\nAdditionally, the service caches ReverseProxy objects used to proxy the requests to the underlying URL.\n\n## Handling of headers\n\nThe Application Gateway removes the following headers while making calls to the registered applications:\n\n- `X-Forwarded-Proto`\n- `X-Forwarded-For`\n- `X-Forwarded-Host`\n- `X-Forwarded-Client-Cert`\n\nIn addition, the `User-Agent` header is set to an empty value not specified in the call, which prevents from setting the default value.\n","type":"Architecture"},{"order":"02-04-application-broker","title":"Application Broker","source":"\nThe Application Broker (AB) workflow consists of the following steps:\n\n1. The Application Broker watches for Applications (Apps) in the cluster and ApplicationMappings (AMs) in all Namespaces.\n2. The user creates an ApplicationMapping custom resource in a given Namespace. The AM activates services offered by an App. The AM must have the same name as the App.\n3. The Application Broker creates an `application-broker` Service Broker (SB) inside the Namespace in which the AM is created. This Service Broker contains data of all services provided by the activated Applications. There is always only one `application-broker` Service Broker per Namespace, even if there are more AMs.\n4. The Service Catalog fetches services that the `application-broker` Service Broker exposes.\n5. The Service Catalog creates a ServiceClass for each service received from the Service Broker.\n\n![AB architecture](./assets/004-AB-architecture.svg)\n\nWhen this process is complete, you can provision and bind your services.\n\n## Provisioning and binding for an API ServiceClass\n\nThis ServiceClass has a **bindable** flag set to `true` which means that you have to provision a ServiceInstance and bind it to the service or lambda to connect to the given API. The provisioning and binding workflow for an API ServiceClass consists of the following steps:\n1. Select an API ServiceClass from the Service Catalog.\n2. Provision this ServiceClass by creating its ServiceInstance in a Namespace.\n3. Bind your ServiceInstance to the service or lambda. During the binding process, ServiceBinding and ServiceBindingUsage resources are created.\n    * ServiceBinding contains a Secret with a GatewayURL required to connect to the given API.\n    * ServiceBindingUsage injects the Secret, together with the label given during the registration process, to the lambda or service.\n4. The service or lambda calls the API through the Application Connector. The Application Connector verifies the label to check if you have the authorization to access this API.\n5. After verifying the label, the Application Connector allows you to access the Application API.\n\n![API Service Class](./assets/005-AB-API-service-class.svg)\n\n## Provisioning and binding for an Event ServiceClass\n\nThis ServiceClass has a **bindable** flag set to `false` which means that after provisioning a ServiceClass in the Namespace, given Events are ready to use for all services. The provisioning workflow for an Event ServiceClass consists of the following steps:\n1. Select a given Event ServiceClass from the Service Catalog.\n2. Provision this ServiceClass by creating a ServiceInstance in the given Namespace.\n3. During the provisioning process, the EventActivation resource is created together with the ServiceInstance. EventActivation allows you to create an Event Bus Subscription.\n4. A Subscription is a custom resource by which an Event Bus triggers the lambda for a particular type of Event in this step.\n5. The Application sends an Event to the Application Connector.\n6. The Application Connector sends an Event to the lambda through the Event Bus.\n\n\n![Event Service Class](./assets/006-AB-event-service-class.svg)\n\n## Provisioning and binding for both the API and Event ServiceClass\n\nThis ServiceClass has a **bindable** flag set to `true`.\nThe provisioning and binding workflow for both the API and Event ServiceClass is a combination of steps described for an [API ServiceClass](#architecture-the-application-broker-architecture-provisioning-and-binding-for-an-api-serviceclass) and an [Event ServiceClass](#architecture-the-application-broker-architecture-provisioning-and-binding-for-an-event-serviceclass).\n","type":"Architecture"},{"order":"03-01-ac-security","title":"Security","source":"\n## Client certificates\n\nTo provide maximum security, the Application Connector uses TLS protocol with Client Authentication enabled. As a result, whoever wants to connect to the Application Connector must present a valid client certificate, which is dedicated to a specific Application (App). In this way, the traffic is fully encrypted and the client has a valid identity.\n\n## Disable SSL certificate verification\n\nYou can disable the SSL certificate verification in the communication between Kyma and an App to allow Kyma to send requests and data to an unsecured App. Disabling the certificate verification can be useful in certain testing scenarios.\n\n>**NOTE:** By default, the SSL certificate verification is enabled when sending data and requests to every App.\n\nFollow these steps to disable SSL certificate verification for communication between Kyma and an existing App:\n\n  1. Edit the `{APPLICATION}-application-gateway` Deployment in the `kyma-integration` Namespace. Run:\n    ```\n    kubectl -n kyma-integration edit deployment {APPLICATION}-application-gateway\n    ```\n  2. Edit the Deployment in Vim. Select `i` to start editing.\n  3. Find the **skipVerify** parameter and change its value to `true`.\n  4. Select `esc`, type `:wq`, and select `enter` to write and quit.\n\n## Override the API security type\n\nThe Application Registry allows you to register APIs:\n- Secured with [Basic Authentication](https://tools.ietf.org/html/rfc7617)\n- Secured with OAuth flow\n- Secured with client certificates\n- Not secured\n- Protected against cross-site request forgery (CSRF) attacks\n\nThe Application Gateway calls the registered APIs accordingly, basing on the security type specified in the API registration process.\n\nThe Application Gateway overrides the registered APIs security type if it gets a request which contains the **Access-Token** header. In such a case, the Application Gateway rewrites the token from the **Access-Token** header into an OAuth-compliant **Authorization** header and forwards it to the target API.\n\nThis mechanism is suited for implementations in which an external application handles user authentication.\n","type":"Details"},{"order":"03-02-access-ac-on-local","title":"Access the Application Connector on a local Kyma deployment","source":"\nTo access the Application Connector on a local deployment of Kyma, you must add the Kyma server certificate to the trusted certificate storage of your programming environment. This is necessary to connect the external solution to your local Kyma deployment, allow client certificate exchange, and API registration.\n\nFor example, to access the Application Connector from a Java environment, run this command to add the Kyma server certificate to the Java Keystore:\n```\nsudo {JAVA_HOME}/bin/keytool -import -alias “Kyma” -keystore {JAVA_HOME}/jre/lib/security/cacerts -file {KYMA_HOME}/installation/certs/workspace/raw/server.crt\n```\n","type":"Details"},{"order":"03-03-consume-services","title":"Consume applications through the Service Catalog","source":"\nTo consume an external solution connected to Kyma, you must register it as an Application (App). As a result of registering the external solution, ClusterServiceClasses are created in the Service Catalog.\n\n## External solution's services in the Service Catalog\n\nThe Example API is registered in Kyma with the `targetUrl` pointing to `https://www.orders.com/v1/orders`. The ID assigned to the API in the registration process is `01a702b8-e302-4e62-b678-8d361b627e49`.\n\nThe Application Broker, which provides ServiceClasses to the Service Catalog, follows this naming convention for its objects:\n```\napp-{application-name}-{service-id}\n```\nThe `{service-id}` is the service identifier assigned in the process of registration. The `{application}` is the name of the App created in Kyma. It represents an instance of the connected external solution that owns the registered service. Such identifier used by the Application Broker is referred to as the `name` of a ClusterServiceClass in the Service Catalog.\n\nThis an example of a full ClusterServiceClass `name`:\n```\nre-ec-default-01a702b8-e302-4e62-b678-8d361b627e49\n```\n\n## Service consumption\n\nAfter you provision the Example API in the Namespace of your choice using the Service Catalog, you can bind it to your application and consume it by calling the URL you get as a result of a successful binding.\n\nThis is a sample URL for the Example API:\n```\nre-ec-default-01a702b8-e302-4e62-b678-8d361b627e49.kyma-integration/orders\n```\n\nWhen you call this URL, the Application Gateway passes all requests to the `https://www.orders.com/v1/orders` address, which is the `targetUrl` registered for the Example API. You do not have to get an OAuth token and manually include it in the call as the Application Gateway does it for you automatically.\n","type":"Details"},{"order":"03-04-metadata-service","title":"Application Registry","source":"\nThe Application Registry allows you to register the APIs and Event catalogs of the services exposed by the connected external solution.         \n\nThe Application Registry stores the data of all registered services in:\n- Application custom resource (CR), which stores the metadata of the service.\n- Docs Topic Custom Resource (CR), which stores the links to API specification, Event catalog, and documentation.\n- Upload Service, which stores the files containing API specification, Event catalog, and documentation in an Asset Store bucket.\n- Kubernetes secrets, which stores sensitive data, such as OAuth credentials.\n\n## Kubernetes APIs interaction\n\nThe Application Registry interacts with Kubernetes APIs to perform these tasks:\n- Modify the Application CR instance.\n- Create Secrets which contain client ID and client secret used to access OAuth-secured APIs.\n- Create the Access Service.","type":"Details"},{"order":"03-05-pass-access-token-in-request-header","title":"Pass an access token in a request header","source":"\nThe Application Connector supports passing the access token directly in the request.\n\n## Passing the access token\n\nIf the user is already authenticated to the target API, the access token can be passed in a custom `Access-token` header. The value of the header is of the `Bearer {token}` or `Basic {token}` form. If the Application Connector detects that the custom header is present, instead of performing authentication steps, it removes the `Access-token` header, and passes the received value in the `Authorization` header.\n","type":"Details"},{"order":"03-06-payload-limits-for-apis","title":"Payload size limits for registering APIs","source":"\nThe Application Connector allows you to adjust the payload size limit for registering API definitions. You can tune the limit individually for every Application in your Kyma cluster.\n\nThe `nginx.ingress.kubernetes.io/proxy-body-size` annotation defines the maximum payload size. By default, every Application you create comes with the payload size limit set to 5 MB. You can adjust it to fit the needs of your implementation.\n\nTo change the maximum payload size for an API definition, edit the configuration of the Ingress of the Application for which you want to tune the limit. Run this command to edit the Ingress configuration:\n\n```\nkubectl -n kyma-integration edit ingress {APPLICATION_NAME}-application\n```\n","type":"Details"},{"order":"03-07-api-registration","title":"API registration in the Application Registry","source":"\nThe Application Registry supports the following formats of the API specification:\n- OpenAPI 2.0\n- OData XML 2.0, 3.0 and 4.0\n\nYou can pass the API specification in two ways:\n- JSON format\n- `SpecificationUrl`\n\n>**NOTE:** Specification passed directly as a JSON has a higher priority than `SpecificationUrl`.  If you use these two methods at once, `SpecificationUrl` is ignored.\n\nFor the OpenAPI format, both methods are supported.\nYou can register OData APIs only with `SpecificationUrl`.\n","type":"Details"},{"order":"06-01-application","title":"Application","source":"\nThe `applications.applicationconnector.kyma-project.io` CustomResourceDefinition (CRD) is a detailed description of the kind of data and the format used to register an Application (App) in Kyma. The `Application` custom resource defines the APIs that the App offers. After creating a new custom resource for a given App, the App is mapped to appropriate ServiceClasses in the Service Catalog. To get the up-to-date CRD and show the output in the `yaml` format, run this command:\n\n```\nkubectl get crd applications.applicationconnector.kyma-project.io -o yaml\n```\n\n## Sample custom resource\n\nThis is a sample resource that registers the `system-prod` App which offers one service.\n\n>**NOTE:** The name of the App must consist of lower case alphanumeric characters, `-` or `.`, and start and end with an alphanumeric character.\n\n```\napiVersion: applicationconnector.kyma-project.io/v1alpha1\nkind: Application\nmetadata:\n  name: system-prod\nspec:\n  description: This is the system-production Application.\n  labels:\n    region: us\n    kind: production\n```\n\n## Custom resource parameters\n\nThis table lists all the possible parameters of a given resource together with their descriptions:\n\n| Parameter   |      Mandatory      |  Description |\n|:----------:|:-------------:|:------|\n| **metadata.name** |    **YES**   | Specifies the name of the CR. |\n| **spec.description** |    **NO**   | Describes the connected Application.  |\n| **spec.accessLabel** |    **NO**   | Labels the App when an ApplicationMapping is created. |\n| **spec.labels** |    **NO**   | Defines the labels of the App. |\n| **spec.services** |    **NO**   | Contains all services that the Application provides. |\n| **spec.services.id** |    **YES**   | Identifies the service that the Application provides. |\n| **spec.services.identifier** |    **NO**   | Provides an additional identifier of the ServiceClass. |\n| **spec.services.name** |    **NO**   | Represents a unique name of the service used by the Service Catalog. |\n| **spec.services.displayName** |    **YES**   | Specifies a human-readable name of the Application service. Parameter provided by the Application Registry, do not edit. |\n| **spec.services.description** |    **NO**   | Provides a short, human-readable description of the service offered by the App. Parameter provided by the Application Registry, do not edit. |\n| **spec.services.longDescription** |    **NO**   | Provides a longer, human-readable description of the service offered by the App. Parameter provided by the Application Registry, do not edit. |\n| **spec.services.providerDisplayName** |    **YES**   | Specifies a human-readable name of the Application service provider. Parameter provided by the Application Registry, do not edit. |\n| **spec.services.tags** |    **NO**   | Specifies additional tags used for better documentation of the available APIs. Parameter provided by the Application Registry, do not edit. |\n| **spec.services.labels** |    **NO**   | Specifies additional labels for the service offered by the App. Parameter provided by the Application Registry, do not edit. |\n| **spec.services.entries** |    **YES**   | Contains the information about the APIs and Events that the service offered by the App provides. Parameter provided by the Application Registry, do not edit. |\n| **spec.services.entries.type** |    **YES**   | Specifies the entry type: API or Event. Parameter provided by the Application Registry, do not edit. |\n| **spec.services.entries.gatewayUrl** |    **NO**   | Specifies the URL of the Application Connector. This field is required for the API entry type. Parameter provided by the Application Registry, do not edit. |\n| **spec.services.entries.accessLabel** |    **NO**   | Specifies the label used in Istio rules in the Application Connector. This field is required for the API entry type. |\n| **spec.services.entries.targetUrl** |    **NO**   | Specifies the URL of a given API. This field is required for the API entry type. Parameter provided by the Application Registry, do not edit. |\n| **spec.services.entries.oauthUrl** |    **NO**   | Specifies the URL used to authorize with a given API. This field is required for the API entry type. Parameter provided by the Application Registry, do not edit. |\n| **spec.services.entries.credentialsSecretName** |    **NO**   | Specifies the name of the Secret which allows you to call a given API. This field is required if **spec.services.entries.oauthUrl** is specified. Parameter provided by the Application Registry, do not edit. |\n\n## Related resources and components\n\nThese components use this CR:\n\n| Component   |  Description |\n|:-----------:|:-------------|\n| Application Registry | Reads and saves the APIs and Event Catalog metadata of the connected external solution in this CR. |\n| Application Broker | Exposes the APIs and Event definitions stored in this CR as ServiceClasses to the Service Catalog. |\n| Application Operator | Provisions and de-provisions an instance of Application Gateway and Event Service for every created or deleted Application CR. |\n\n## Additional information\n\nThe Application Operator adds the **status** section which describes the status of the App installation to the created CR periodically. This table lists the fields of the **status** section.\n\n| Field   |  Description |\n|:----------:|:-------------:|\n| **status.installationStatus** | Describes the status of the App installation. |\n| **status.installationStatus.description** | Provides a longer description of the installation status. |\n| **status.installationStatus.status** | Provides a short, human-readable description of the installation status. |\n","type":"Custom Resource"},{"order":"06-02-apllicationmapping","title":"ApplicationMapping","source":"\nThe `applicationmappings.application.kyma-project.io` CustomResourceDefinition (CRD) is a detailed description of the kind of data and the format used to enable APIs and Events from an Application (App) as a ServiceClass in a given Namespace. To get the up-to-date CRD and show the output in the `yaml` format, run this command:\n\n```\nkubectl get crd applicationmappings.applicationconnector.kyma-project.io -o yaml\n```\n\n## Sample custom resource\n\nThis is a sample ApplicationMapping resource which enables the `test` Application in the `production` Namespace:\n\n```\napiVersion: applicationconnector.kyma-project.io/v1alpha1\nkind: ApplicationMapping\nmetadata:\n  name: test\n  namespace: production\n```\n\n## Custom resource parameters\n\nThis table lists all the possible parameters of a given resource together with their descriptions:\n\n| Parameter   |      Mandatory      |  Description |\n|:----------:|:-------------:|:------|\n| **metadata.name** |    **YES**   | Specifies the name of the CR and the App. |\n| **metadata.namespace** |    **YES**   | Specifies the Namespace in which the App is enabled. |\n\n## Related resources and components\n\nThese components use this CR:\n\n| Component   |   Description |\n|:----------:|:------|\n| Application Broker |  Uses this CR to enable the provisioning of ServiceClasses in a given Namespace. |\n| Console Backend Service | Uses this CR to filter the enabled Apps. It also allows you to create or delete ApplicationMappings. |\n","type":"Custom Resource"},{"order":"06-03-event-activation","title":"EventActivation","source":"\nThe `eventactivations.applicationconnector.kyma-project.io` CustomResourceDefinition (CRD) is a detailed description of the kind of data and the format used to create an Event Bus Subscription and to get an Event schema. To get the up-to-date CRD and show the output in the `yaml` format, run this command:\n\n```\nkubectl get crd eventactivations.applicationconnector.kyma-project.io -o yaml\n```\n\n## Sample custom resource\n\nThis is a sample resource that allows you to consume Events sent from the service with the `ac031e8c-9aa4-4cb7-8999-0d358726ffaa` ID in a `production` Namespace.\n\n```\napiVersion: applicationconnector.kyma-project.io/v1alpha1\nkind: EventActivation\nmetadata:\n  name: \"ac031e8c-9aa4-4cb7-8999-0d358726ffaa\"\n  namespace: production\nspec:\n  displayName: \"Orders\"\n  sourceId: \"prod\"\n```\n\n## Custom resource parameters\n\nThis table lists all the possible parameters of a given resource together with their descriptions:\n\n\n| Parameter   |      Mandatory      |  Description |\n|:----------:|:-------------:|:------|\n| **metadata.name** |    **YES**   | Specifies the name of the CR and the ID of the Application service. This field is also used to fetch Event schemas from the Minio storage.  |\n| **metadata.namespace** |    **YES**   | Specifies the Namespace in which the CR is created. |\n| **spec.displayName** |    **YES**   | Specifies a human-readable name of the Application service. |\n| **spec.sourceId** |    **YES**   | Used to construct a Publish-Subscribe (Pub/Sub) topic name where the Events are send and from where the Events are consumed. |\n\n## Related resources and components\n\nThese are the resources related to this CR:\n\n| Custom resource   |   Description |\n|:----------:|:------|\n| Application |  Describes a service from which the user receives Events. |\n| Subscription | Contains information on how to create an infrastructure for consuming Events. Works only if the EventActivation is enabled.  |\n\nThese components use this CR:\n\n| Component   |   Description |\n|:----------:|:------|\n| Application Broker |  Uses this CR to enable the user to receive Events from a given service. |\n| Event Bus | Uses this CR to control the consumption of an Event.  |\n| Serverless | Lambda UI sends a GraphQL query to Console Backend Service to list EventActivations. |\n| Console Backend Service |  Exposes the given CR to the Console UI. |\n","type":"Custom Resource"},{"order":"06-04-tokenrequest","title":"TokenRequest","source":"\nThe `tokenrequests.applicationconnector.kyma-project.io` CustomResourceDefinition (CRD) is a detailed description of the kind of data and the format used to request token for Application (App) configuration URL from the Connector Service. To get the up-to-date CRD and show the output in the `yaml` format, run this command:\n\n```\nkubectl get crd tokenrequests.applicationconnector.kyma-project.io -o yaml\n```\n\n## Sample custom resource\n\nThis is a sample custom resource (CR) which allows to get the configuration required to connect an external solution to the `test` App.\n\n```\napiVersion: applicationconnector.kyma-project.io/v1alpha1\nkind: TokenRequest\nmetadata:\n  name: test-app\ncontext:\n  tenant: test-tenant\n  group: test-group\n```\n\n## Custom resource parameters\n\nThis table lists all the possible parameters of a given resource together with their descriptions:\n\n| Parameter   |      Mandatory      |  Description |\n|:----------:|:-------------:|:------|\n| **metadata.name** |    **YES**   | Specifies the name of the CR and the App to request token for. |\n| **context.tenant**|    **NO**    | Specifies the name of the Tenant.  |\n| **context.group** |    **NO**    | Specifies the name of the Group. |\n\n\n## Additional information\n\nWhen you fetch an existing TokenRequest CR, the system adds the **status** section which describes the status of the request and lists the configuration details. This table lists the fields of the **status** section.\n\n| Field   |  Description |\n|:----------:|:-------------:|\n| **status.expireAfter** | Date and time after wich the token will expire and the controller will delete the CR. |\n| **status.application** | The name of the App for which the token was issued. |\n| **status.state** | Status of the token request. This field can have one of two values: `OK` or `ERR`. |\n| **status.token** | The token generated by the Connector Service. |\n| **status.url** | The URL to the Connector Service info endpoint with the token. |\n","type":"Custom Resource"},{"order":"08-01-create-application","title":"Create a new Application","source":"\nThe Application Operator listens for the creation of Application custom resources. It provisions and de-provisions the necessary deployments for every created Application (App).\n\n>**NOTE:** An App represents a single connected external solution.\n\nTo create a new App, run this command:\n\n```\ncat <<EOF | kubectl apply -f -\napiVersion: applicationconnector.kyma-project.io/v1alpha1\nkind: Application\nmetadata:\n  name: {APP_NAME}\nspec:\n  description: {APP_DESCRIPTION}\n  labels:\n    region: us\n    kind: production\nEOF\n```\n\n## Check the App status\n\nTo check the status of the created App and show the output in the `yaml` format, run this command:\n```\nkubectl get app {APP_NAME} -o yaml\n```\n\nA successful response returns the Application custom resource with the specified name. The custom resource has the **status** section added.\nThis is an example response:\n\n```\napiVersion: applicationconnector.kyma-project.io/v1alpha1\nkind: Application\nmetadata:\n  clusterName: \"\"\n  creationTimestamp: 2018-11-22T13:53:20Z\n  generation: 1\n  name: test1\n  namespace: \"\"\n  resourceVersion: \"30728\"\n  selfLink: /apis/applicationconnector.kyma-project.io/v1alpha1/applications/test1\n  uid: f8ca5595-ee5d-11e8-acb2-000d3a443243\nspec:\n  accessLabel: {APP_NAME}\n  description: {APP_DESCRIPTION}\n  labels: {}\n  services: []\nstatus:\n  installationStatus:\n    description: Installation complete\n    status: DEPLOYED\n```\n","type":"Tutorials"},{"order":"08-02-get-client-certificate","title":"Get the client certificate","source":"\nAfter you create an Application (App), connect it to an external solution to consume the solution's APIs and Event catalogs in Kyma. To accomplish this, get the client certificate for the external solution and register its services.\n\nThis guide shows you how to get the client certificate.\n\n>**NOTE:** The client certificate is valid for 92 days. See [this](#tutorials-renew-the-client-certificate) tutorial to learn how to renew the client certificate. \nYou can also revoke the client certificate, which prevents it from being renewed. See [this](#tutorials-revoke-the-client-certificate) tutorial to learn how to do this.\n\n## Prerequisites\n\n- [OpenSSL toolkit](https://www.openssl.org/docs/man1.0.2/apps/openssl.html) to create a Certificate Signing Request (CSR), keys, and certificates which fulfil high security standards\n\n## Get the configuration URL with a token\n\nTo get the configuration URL which allows you to fetch the required configuration details, create a TokenRequest custom resource (CR). The controller which handles this CR kind adds the **status** section to the created CR. The **status** section contains the required configuration details.\n\n- Create a TokenRequest CR. The CR name must match the name of the App for which you want to get the configuration details. Run:\n  ```\n  cat <<EOF | kubectl apply -f -\n  apiVersion: applicationconnector.kyma-project.io/v1alpha1\n  kind: TokenRequest\n  metadata:\n    name: {APP_NAME}\n  EOF\n  ```\n\n- Fetch the TokenRequest CR you created to get the configuration details from the **status** section. Run:\n  ```\n  kubectl get tokenrequest.applicationconnector.kyma-project.io {APP_NAME} -o yaml\n  ```\n  >**NOTE:** If the response doesn't contain the **status** section, wait for a few moments and fetch the CR again.\n\nA successful call returns the following response:\n  ```\n  apiVersion: applicationconnector.kyma-project.io/v1alpha1\n  kind: TokenRequest\n  metadata:\n    name: {APP_NAME}\n  status:\n    expireAfter: 2018-11-22T18:38:44Z\n    application: {APP_NAME}\n    state: OK\n    token: h31IwJiLNjnbqIwTPnzLuNmFYsCZeUtVbUvYL2hVNh6kOqFlW9zkHnzxYFCpCExBZ_voGzUo6IVS_ExlZd4muQ==\n    url: https://connector-service.kyma.local/v1/applications/signingRequests/info?token=h31IwJiLNjnbqIwTPnzLuNmFYsCZeUtVbUvYL2hVNh6kOqFlW9zkHnzxYFCpCExBZ_voGzUo6IVS_ExlZd4muQ==\n  ```\n\n## Get the CSR information and configuration details from Kyma\n\nUse the link you got in the previous step to fetch the CSR information and configuration details required to connect your external solution. Run:\n\n```\ncurl {CONFIGURATION_URL_WITH_TOKEN}\n```\n>**NOTE:** The URL you call in this step contains a token that is valid for 5 minutes or for a single call. You get a code `403` error if you call the same configuration URL more than once, or if you call an URL with an expired token.\n\nA successful call returns the following response:\n```\n{\n    \"csrUrl\": \"{CSR_SIGNING_URL_WITH_TOKEN}\",\n    \"api\":{\n        \"metadataUrl\":      \"https://gateway.{CLUSTER_DOMAIN}/{APP_NAME}/v1/metadata/services\",\n        \"eventsUrl\":        \"https://gateway.{CLUSTER_DOMAIN}/{APP_NAME}/v1/events\",\n        \"infoUrl\":          \"https://gateway.{CLUSTER_DOMAIN}/v1/applications/management/info\",\n        \"certificatesUrl\":  \"https://connector-service.{CLUSTER_DOMAIN}/v1/applications/certificates\",\n    },\n    \"certificate\":{\n        \"subject\":\"OU=Test,O=TestOrg,L=Waldorf,ST=Waldorf,C=DE,CN={APP_NAME}\",\n        \"extensions\": \"\",\n        \"key-algorithm\": \"rsa2048\",\n    }\n}\n```\n\n> **NOTE:** The response contains URLs to the Application Registry API and the Events Service API, however, it is not recommended to use them. You should call the `metadata` endpoint URL, which is provided in `api.infoUrl` property, to fetch correct URLs to the Application Registry API and to the Events Service API, and other configuration details.\n\n## Generate a CSR and send it to Kyma\n\nGenerate a CSR using the certificate subject data obtained in the previous step:\n```\nopenssl genrsa -out generated.key 2048\nopenssl req -new -sha256 -out generated.csr -key generated.key -subj \"/OU=Test/O=TestOrg/L=Waldorf/ST=Waldorf/C=DE/CN={APP_NAME}\"\nopenssl base64 -in generated.csr\n```\n\nSend the encoded CSR to Kyma. Run:\n```\ncurl -H \"Content-Type: application/json\" -d '{\"csr\":\"BASE64_ENCODED_CSR_HERE\"}' {CSR_SIGNING_URL_WITH_TOKEN}\n```\n\nThe response contains a valid client certificate signed by the Kyma Certificate Authority.\n```\n{\n    \"crt\":\"BASE64_ENCODED_CRT_CHAIN\",\n    \"clientCrt\":\"BASE64_ENCODED_CLIENT_CRT\",\n    \"caCrt\":\"BASE64_ENCODED_CA_CRT\"\n}\n```\n\nAfter you receive the certificate, decode it and use it in your application. \n\n## Call the metadata endpoint\n\nCall the `metadata` endpoint with the generated certificate to get URLs to the following:\n\n- the Application Registry API\n- the Events Service API\n- the `certificate renewal` endpoint\n- the `certificate revocation` endpoint\n\nThe URL to the `metadata` endpoint is returned in the response body from the configuration URL. Use the value of the `api.infoUrl` property to get the URL. Run:\n\n```\ncurl {CLUSTER_DOMAIN}/v1/applications/management/info --cert {CERT_FILE_NAME}.crt --key {KEY_FILE_NAME}.key\n```\n\nA successful call returns the following response:\n\n```\n{\n  \"clientIdentity\": {\n    \"application\": \"{APP_NAME}\"\n  },\n  \"urls\": {\n    \"metadataUrl\": \"https://gateway.{CLUSTER_DOMAIN}/{APP_NAME}/v1/metadata/services\",\n    \"eventsUrl\": \"https://gateway.{CLUSTER_DOMAIN}/{APP_NAME}/v1/events\",\n    \"renewCertUrl\": \"https://gateway.{CLUSTER_DOMAIN}/v1/applications/certificates/renewals\",\n    \"revokeCertUrl\": \"https://gateway.{CLUSTER_DOMAIN}/v1/applications/certificates/revocations\"\n  },\n  \"certificate\": {\n    \"subject\": \"OU=Test,O=Test,L=Blacksburg,ST=Virginia,C=US,CN={APP_NAME}\",\n    \"extensions\": \"string\",\n    \"key-algorithm\": \"rsa2048\"\n  }\n}\n```\n\nUse `urls.metadataUrl` and `urls.eventsUrl` to get the URLs to the Application Registry API and to the Events API.\n\n## Call the Application Registry and Event services on local deployment\n\nWhen you connect an external solution to a local Kyma deployment, you must pass the NodePort of the `application-connector-ingress-nginx-ingress-controller` to successfully call the Application Registry and the Event Service.\n\n- To get the NodePort, run:\n  ```\n  kubectl -n kyma-system get svc application-connector-ingress-nginx-ingress-controller -o 'jsonpath={.spec.ports[?(@.port==443)].nodePort}'\n  ```\n- When you send requests to the Application Registry and the Event Service, pass the NodePort along with the generated certificate and key. For example:\n  ```\n  curl https://gateway.kyma.local:{NODE_PORT}/{APP_NAME}/v1/metadata/services --cert {CERT_FILE_NAME}.crt --key {KEY_FILE_NAME}.key -k\n  ```\n  ```\n  curl https://gateway.kyma.local:{NODE_PORT}/{APP_NAME}/v1/events --cert {CERT_FILE_NAME}.crt --key {KEY_FILE_NAME}.key -k\n  ```\n","type":"Tutorials"},{"order":"08-03-register-manage-services","title":"Register a service","source":"\nThis guide shows you how to register a service of your external solution in Kyma.\n\n## Prerequisites\n\nValid certificate signed by the Kyma Certificate Authority.\n\n## Register a service\n\n1. To register a service with a Basic Authentication-secured API, follow this template to prepare the request body:\n  >**NOTE:** Follow [this](#tutorials-register-a-secured-api) tutorial to learn how to register APIs secured with different security schemes or protected against cross-site request forgery (CSRF) attacks.\n\n  ```\n  {\n    \"provider\": \"example-provider\",\n    \"name\": \"example-name\",\n    \"description\": \"This is the long description of your service\",\n    \"shortDescription\": \"Short description\",\n    \"labels\": {\n      \"example\": \"true\"\n    },\n    \"api\": {\n      \"targetUrl\": \"https://httpbin.org/\",\n      \"spec\": {},\n      \"credentials\": {\n        \"basic\": {\n          \"username\": \"{USERNAME}\",\n          \"password\": \"{PASSWORD}\"\n        }\n      }\n    },\n    \"events\": {\n      \"spec\": {\n        \"asyncapi\": \"1.0.0\",\n        \"info\": {\n          \"title\": \"PetStore Events\",\n          \"version\": \"1.0.0\",\n          \"description\": \"Description of all the events\"\n        },\n        \"baseTopic\": \"stage.com.some.company.system\",\n        \"topics\": {\n          \"petCreated.v1\": {\n            \"subscribe\": {\n              \"summary\": \"Event containing information about new pet added to the Pet Store.\",\n              \"payload\": {\n                \"type\": \"object\",\n                \"properties\": {\n                  \"pet\": {\n                    \"type\": \"object\",\n                    \"required\": [\n                      \"id\",\n                      \"name\"\n                    ],\n                    \"example\": {\n                      \"id\": \"4caad296-e0c5-491e-98ac-0ed118f9474e\",\n                      \"category\": \"mammal\",\n                      \"name\": \"doggie\"\n                    },\n                    \"properties\": {\n                      \"id\": {\n                        \"title\": \"Id\",\n                        \"description\": \"Resource identifier\",\n                        \"type\": \"string\"\n                      },\n                      \"name\": {\n                        \"title\": \"Name\",\n                        \"description\": \"Pet name\",\n                        \"type\": \"string\"\n                      },\n                      \"category\": {\n                        \"title\": \"Category\",\n                        \"description\": \"Animal category\",\n                        \"type\": \"string\"\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    \"documentation\": {\n      \"displayName\": \"Documentation\",\n      \"description\": \"Description\",\n      \"type\": \"some type\",\n      \"tags\": [\"tag1\", \"tag2\"],\n      \"docs\": [\n          {\n          \"title\": \"Documentation title...\",\n          \"type\": \"type\",\n          \"source\": \"source\"\n          }\n      ]\n    }\n  }\n  ```\n\n2. Include the request body you prepared in the following call to register a service:\n\n  - For a cluster deployment:\n    ```\n    curl -X POST -d '{YOUR_REQUEST_BODY}' https://gateway.{CLUSTER_DOMAIN}/{APP_NAME}/v1/metadata/services --cert {CERT_FILE_NAME}.crt --key {KEY_FILE_NAME}.key -k\n    ```\n\n  - For a local deployment:\n    ```\n    curl -X POST -d '{YOUR_REQUEST_BODY}' https://gateway.kyma.local:{NODE_PORT}/{APP_NAME}/v1/metadata/services --cert {CERT_FILE_NAME}.crt --key {KEY_FILE_NAME}.key -k\n    ```\n\nA successful response returns the ID of the registered service:\n```\n{\"id\":\"{YOUR_SERVICE_ID}\"}\n```\n\n### Check the details of a registered service\n\n  - For a cluster deployment:\n    ```\n    curl https://gateway.{CLUSTER_DOMAIN}/{APP_NAME}/v1/metadata/services/{YOUR_SERVICE_ID} --cert {CERT_FILE_NAME}.crt --key {KEY_FILE_NAME}.key -k\n    ```\n\n  - For a local deployment:\n    ```\n    curl https://gateway.kyma.local:{NODE_PORT}/{APP_NAME}/v1/metadata/services/{YOUR_SERVICE_ID} --cert {CERT_FILE_NAME}.crt --key {KEY_FILE_NAME}.key -k\n    ```\n\n\n## Register API with a specification URL\n\nThe Application Registry allows you to pass API specifications in a form of specification URLs.\n\nTo register API with specification URL, replace `api.spec` with `api.specificationUrl`. \n\n>**NOTE:** If both api.spec and api.specificationUrl are provided, api.spec will be used due to its higher priority.\n\nSee the example of the API part of the request body with specification URL:\n```\n\"api\": {\n  \"targetUrl\": \"https://services.odata.org/OData/OData.svc\",\n  \"specificationUrl\": \"https://services.odata.org/OData/OData.svc/$metadata\",\n  \"credentials\": {\n    \"basic\": {\n      \"username\": \"{USERNAME}\",\n      \"password\": \"{PASSWORD}\"\n    }\n}\n```\n\nThe Application Registry will fetch the specification from provided URL but it will not use any credentials, therefore the endpoint can not be secured by any authentication mechanism.\n\n>**NOTE:** Fetching specification from a URL is supported only for APIs. Fetching specifications for Events or documentation is not supported.\n\n\n## Register the OData API\n\nIf the **api.spec** or **api.specificationUrl** parameters are not specified and the **api.type** parameter is set to `OData`, the Application Registry will try to fetch specification from the target URL with the `$metadata` path.\n\nFor example, for the service with the following API, the Application Registry will try to fetch API specification from `https://services.odata.org/OData/OData.svc/$metadata`.\n```\n\"api\": {\n  \"targetUrl\": \"https://services.odata.org/OData/OData.svc\",\n  \"apiType\": \"OData\"\n  \"credentials\": {\n    \"basic\": {\n      \"username\": \"{USERNAME}\",\n      \"password\": \"{PASSWORD}\"\n    }\n}\n```\n","type":"Tutorials"},{"order":"08-04-register-secured-api","title":"Register a secured API","source":"\nThe Application Registry allows you to register a secured API for every service. The supported authentication methods are [Basic Authentication](https://tools.ietf.org/html/rfc7617), [OAuth](https://tools.ietf.org/html/rfc6750), and client certificates.\n\nYou can specify only one authentication method for every secured API you register. If you try to register and specify more than one authentication method, the Application Registry returns a `400` code response.\n\nAdditionally, you can secure the API against cross-site request forgery (CSRF) attacks. CSRF tokens are an additional layer of protection and can accompany any authentication method.  \n\n>**NOTE:** Registering a secured API is a part of registering services of an external solution connected to Kyma. To learn more about this process, follow [this](#tutorials-register-a-service) tutorial.\n\n## Register a Basic Authentication-secured API\n\nTo register an API secured with Basic Authentication, add a `credentials.basic` object to the `api` section of the service registration request body. You must include these fields:\n\n| Field   |  Description |\n|:----------:|:------|\n| **username** | Basic Authorization username |\n| **password** | Basic Authorization password |\n\nThis is an example of the `api` section of the request body for an API secured with Basic Authentication:\n\n```\n    \"api\": {\n        \"targetUrl\": \"https://sampleapi.targeturl/v1\",\n        \"credentials\": {\n            \"basic\": {\n                \"username\": \"{USERNAME}\",\n                \"password\": \"{PASSWORD}\"\n            },\n        }  \n```\n## Register an OAuth-secured API\n\nTo register an API secured with OAuth, add a `credentials.oauth` object to the `api` section of the service registration request body. You must include these fields:\n\n| Field   |  Description |\n|:----------:|:------|\n| **url** |  OAuth token exchange endpoint of the service |\n| **clientId** | OAuth client ID |\n| **clientSecret** | OAuth client Secret |    \n\nThis is an example of the `api` section of the request body for an API secured with OAuth:\n\n```\n    \"api\": {\n        \"targetUrl\": \"https://sampleapi.targeturl/v1\",\n        \"credentials\": {\n            \"oauth\": {\n                \"url\": \"https://sampleapi.targeturl/authorizationserver/oauth/token\",\n                \"clientId\": \"{CLIENT_ID}\",\n                \"clientSecret\": \"{CLIENT_SECRET}\"\n            },\n        }  \n```\n\n## Register a client certificate-secured API\n\nTo register an API and secure it with client certificates, you must add the `credentials.certificateGen` object to the `api` section of the service registration request body. The Application Registry generates a ready to use certificate and key pair for every API registered this way. You can use the generated pair or replace it with your own certificate and key.\n\nInclude this field in the service registration request body:\n\n| Field   |  Description |\n|:----------:|:------|\n| **commonName** |  Name of the generated certificate. Set as the `CN` field of the certificate Subject.  |\n\nThis is an example of the `api` section of the request body for an API secured with generated client certificates:\n\n```\n    \"api\": {\n        \"targetUrl\": \"https://sampleapi.targeturl/v1\",\n        \"credentials\": {\n            \"certificateGen\": {\n                \"commonName\": \"{CERT_NAME}\"\n            },\n        }  \n```\n\n>**NOTE:** If you update the registered API and change the `certificateGen.commonName`, the Application Registry generates a new certificate-key pair for that API. When you delete an API secured with generated client certificates, the Application Registry deletes the corresponding certificate and key.\n\n### Details\n\nWhen you register an API with the `credentials.certificateGen` object, the Application Registry generates a SHA256withRSA-encrypted certificate and a matching key. To enable communication between Kyma and an API secured with this authentication method, set the certificate as a valid authentication medium for all calls coming from Kyma in your external solution.\n\nYou can retrieve the client certificate by sending the following request:\n```\ncurl https://gateway.{CLUSTER_DOMAIN}/{APP_NAME}/v1/metadata/services/{YOUR_SERVICE_ID} --cert {CERT_FILE_NAME}.crt --key {KEY_FILE_NAME}.key -k\n```\nA successful call will return a response body with the details of a registered service and a base64-encoded client certificate.\n\nThe certificate and key pair is stored in a Secret in the `kyma-integration` Namespace. List all Secrets and find the one created for your API:\n\n```\nkubectl -n kyma-integration get secrets\n```\n\nTo fetch the certificate and key encoded with base64, run this command:\n\n```\nkubectl -n kyma-integration get secrets app-{APP_NAME}-{SERVICE_ID} -o yaml\n```\n\n>**NOTE:** Replace the `APP_NAME` placeholder with the name of the Application used to connect the external solution that is the origin of the API. Replace the `SERVICE_ID` placeholder with the ID of the registered service to which the API belongs. You get this ID after you register an external solution's service in Kyma.\n\n\nIf the API you registered provides a certificate-key pair or the generated certificate doesn't meet your security standards or specific needs, you can use a custom certificate-key pair for authentication. To replace the Kyma-generated pair with your certificate and key, run this command:\n\n```\nkubectl -n kyma-integration patch secrets app-{APP_NAME}-{SERVICE_ID} --patch 'data:\n  crt: {BASE64_ENCODED_CRT}\n  key: {BASE64_ENCODED_KEY}'\n```\n\n## Register a CSRF-protected API\n\nThe Application Registry supports CSRF tokens as an additional layer of API protection. To register a CSRF-protected API, add the `credentials.{AUTHENTICATION_METHOD}.csrfInfo` object to the `api` section of the service registration request body.\n\nInclude this field in the service registration request body:\n\n| Field | Description |\n|:-----:|:-----------:|\n| **tokenEndpointURL** | The URL to the upstream service endpoint that exposes CSRF tokens. |\n\nThis is an example of the `api` section of the request body for an API secured with both Basic Authentication and a CSRF token.\n\n```\n    \"api\": {\n        \"targetUrl\": \"https://sampleapi.targeturl/v1\",\n        \"credentials\": {\n            \"basic\": {\n                \"username\": \"{USERNAME}\",\n                \"password\": \"{PASSWORD}\",\n                \"csrfInfo\": {\n                    \"tokenEndpointURL\": \"{TOKEN_ENDPOINT_URL}\"\n                }\n            },\n        }\n```\n","type":"Tutorials"},{"order":"08-05-trigger-lambda-with-event","title":"Trigger a lambda with events","source":"\nThis guide shows how to create a simple lambda function and trigger it with an event.\n\n\n## Prerequisites\n\n- An Application (App) bound to the `production` Namespace\n- Client certificates generated for the connected App.\n\n\n## Steps\n\n1. Register a service with the following specification to the desired App.\n\n>**NOTE:** See [this](#tutorials-get-the-client-certificate) tutorial to learn how to register a service.\n```json\n{\n  \"name\": \"my-events-service\",\n  \"provider\": \"myCompany\",\n  \"Identifier\": \"identifier\",\n  \"description\": \"This is some service\",\n  \"events\": {\n    \"spec\": {\n      \"asyncapi\": \"1.0.0\",\n      \"info\": {\n        \"title\": \"Example Events\",\n        \"version\": \"1.0.0\",\n        \"description\": \"Description of all the example events\"\n      },\n      \"baseTopic\": \"example.events.com\",\n      \"topics\": {\n        \"exampleEvent.v1\": {\n          \"subscribe\": {\n            \"summary\": \"Example event\",\n            \"payload\": {\n              \"type\": \"object\",\n              \"properties\": {\n                \"myObject\": {\n                  \"type\": \"object\",\n                  \"required\": [\n                    \"id\"\n                  ],\n                  \"example\": {\n                    \"id\": \"4caad296-e0c5-491e-98ac-0ed118f9474e\"\n                  },\n                  \"properties\": {\n                    \"id\": {\n                      \"title\": \"Id\",\n                      \"description\": \"Resource identifier\",\n                      \"type\": \"string\"\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n2. Get the `externalName` of the Service Class of the registered service.\n```\nkubectl -n production get serviceclass {SERVICE_ID}  -o jsonpath='{.spec.externalName}'\n```\n\n3. Create a Service Instance for the registered service.\n```\ncat <<EOF | kubectl apply -f -\napiVersion: servicecatalog.k8s.io/v1beta1\nkind: ServiceInstance\nmetadata:\n  name: my-events-service-instance-name\n  namespace: production\nspec:\n  serviceClassExternalName: {EXTERNAL_NAME}\nEOF\n```\n\n4. Create a sample lambda function which sends a request to `http://httpbin.org/uuid`. A successful response logs a `Response acquired successfully! Uuid: {RECEIVED_UUID}` message. To create and register the lambda function in the `production` Namespace, run:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: kubeless.io/v1beta1\nkind: Function\nmetadata:\n  name: my-events-lambda\n  namespace: production\nspec:\n  deployment:\n    spec:\n      template:\n        spec:\n          containers:\n          - name: \"\"\n            resources: {}\n  deps: |-\n    {\n        \"name\": \"example-1\",\n        \"version\": \"0.0.1\",\n        \"dependencies\": {\n          \"request\": \"^2.85.0\"\n        }\n    }\n  function: |-\n    const request = require('request');\n\n    module.exports = { main: function (event, context) {\n        return new Promise((resolve, reject) => {\n            const url = \\`http://httpbin.org/uuid\\`;\n            const options = {\n                url: url,\n            };\n\n            sendReq(url, resolve, reject)\n        })\n    } }\n\n    function sendReq(url, resolve, reject) {\n        request.get(url, { json: true }, (error, response, body) => {\n            if(error){\n                resolve(error);\n            }\n            console.log(\"Response acquired successfully! Uuid: \" + response.body.uuid);\n            resolve(response);\n        })\n    }\n  function-content-type: text\n  handler: handler.main\n  horizontalPodAutoscaler:\n    spec:\n      maxReplicas: 0\n  runtime: nodejs8\n  service:\n    ports:\n    - name: http-function-port\n      port: 8080\n      protocol: TCP\n      targetPort: 8080\n    selector:\n      created-by: kubeless\n      function: my-events-lambda\n  timeout: \"\"\n  topic: exampleEvent\nEOF\n```\n\n5. Create a Subscription to allow events to trigger the lambda function.\n```\ncat <<EOF | kubectl apply -f -\napiVersion: eventing.kyma-project.io/v1alpha1\nkind: Subscription\nmetadata:\n  labels:\n    Function: my-events-lambda\n  name: lambda-my-events-lambda-exampleevent-v1\n  namespace: production\nspec:\n  endpoint: http://my-events-lambda.production:8080/\n  event_type: exampleEvent\n  event_type_version: v1\n  include_subscription_name_header: true\n  max_inflight: 400\n  push_request_timeout_ms: 2000\n  source_id: {APP_NAME}\nEOF\n```\n\n6. Send an event to trigger the created lambda.\n  - On a cluster:\n    ```\n    curl -X POST https://gateway.{CLUSTER_DOMAIN}/{APP_NAME}/v1/events -k --cert {CERT_FILE_NAME}.crt --key {KEY_FILE_NAME}.key -d \\\n    '{\n        \"event-type\": \"exampleEvent\",\n        \"event-type-version\": \"v1\",\n        \"event-id\": \"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa\",\n        \"event-time\": \"2018-10-16T15:00:00Z\",\n        \"data\": \"some data\"\n    }'\n    ```\n  - On a local deployment:\n    ```\n    curl -X POST https://gateway.kyma.local:{NODE_PORT}/{APP_NAME}/v1/events -k --cert {CERT_FILE_NAME}.crt --key {KEY_FILE_NAME}.key -d \\\n    '{\n        \"event-type\": \"exampleEvent\",\n        \"event-type-version\": \"v1\",\n        \"event-id\": \"aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa\",\n        \"event-time\": \"2018-10-16T15:00:00Z\",\n        \"data\": \"some data\"\n    }'\n    ```\n\n7. Check the logs of the lambda function to see if it was triggered. Every time an event successfully triggers the function, this message appears in the logs: `Response acquired successfully! Uuid: {RECEIVED_UUID}`. Run this command:\n```\nkubectl -n production logs \"$(kubectl -n production get po -l function=my-events-lambda -o jsonpath='{.items[0].metadata.name}')\" -c my-events-lambda | grep \"Response acquired successfully! Uuid: \"\n```\n","type":"Tutorials"},{"order":"08-06-call-registered-service-from-kyma","title":"Call a registered external service from Kyma","source":"\nThis guide shows how to call a registered external service from Kyma using a simple lambda function.\n\n\n## Prerequisites\n\n- An Application (App) bound to the `production` Namespace\n- Client certificates generated for the connected App.\n- Map `my-lambda-production.kyma.local` to your Minikube IP to call the lambda function on a local Kyma deployment.\n\n\n## Steps\n\n1. Register a service with the following specification to the desired Application.\n>**NOTE:** See [this](#tutorials-register-a-service) tutorial to learn how to register a service.\n```json\n{\n  \"name\": \"my-service\",\n  \"provider\": \"myCompany\",\n  \"Identifier\": \"identifier\",\n  \"description\": \"This is some service\",\n  \"api\": {\n    \"targetUrl\": \"http://httpbin.org/\",\n    \"spec\": {\n      \"swagger\":\"2.0\"\n    }\n  }\n}\n```\n\n2. Get the `externalName` of the Service Class of the registered service.\n```\nkubectl -n production get serviceclass {SERVICE_ID}  -o jsonpath='{.spec.externalName}'\n```\n\n3. Create a Service Instance for the registered service.\n```\ncat <<EOF | kubectl apply -f -\napiVersion: servicecatalog.k8s.io/v1beta1\nkind: ServiceInstance\nmetadata:\n  name: my-service-instance-name\n  namespace: production\nspec:\n  serviceClassExternalName: {EXTERNAL_NAME}\nEOF\n```\n\n4. Create a lambda function that sends a request to the registered service with an additional path of `/uuid`. A successful response returns a UUID generated by `httpbin.org`. To create and register the lambda function in the `production` Namespace, run:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: kubeless.io/v1beta1\nkind: Function\nmetadata:\n  name: my-lambda\n  namespace: production\nspec:\n  deployment:\n    spec:\n      template:\n        metadata:\n          labels:\n            app-{APP_NAME}-{SERVICE_ID}: \"true\"\n        spec:\n          containers:\n          - env:\n            - name: GATEWAY_URL\n              value: app-{APP_NAME}-{SERVICE_ID}.kyma-integration\n  deps: |-\n    {\n        \"name\": \"example-1\",\n        \"version\": \"0.0.1\",\n        \"dependencies\": {\n          \"request\": \"^2.85.0\"\n        }\n    }\n  function: |-\n    const request = require('request');\n\n    module.exports = { main: function (event, context) {\n        return new Promise((resolve, reject) => {\n            const url = \\`http://\\${process.env.GATEWAY_URL}/uuid\\`;\n            const options = {\n                url: url,\n            };\n\n            sendReq(url, resolve, reject)\n        })\n    } }\n\n    function sendReq(url, resolve, reject) {\n        request.get(url, { json: true }, (error, response, body) => {\n            if(error){\n                resolve(error);\n            }\n            resolve(response.body);\n        })\n    }\n  function-content-type: text\n  handler: handler.main\n  horizontalPodAutoscaler:\n    spec:\n      maxReplicas: 0\n  runtime: nodejs8\n  service:\n    ports:\n    - name: http-function-port\n      port: 8080\n      protocol: TCP\n      targetPort: 8080\n    selector:\n      created-by: kubeless\n      function: my-lambda\n  timeout: \"\"\n  topic: http\nEOF\n```\n\n5. Create a ServiceBinding and a ServiceBindingUsage to bind the Service Instance to the lambda function.\n\n```\ncat <<EOF | kubectl apply -f -\napiVersion: servicecatalog.k8s.io/v1beta1\nkind: ServiceBinding\nmetadata:\n  labels:\n    Function: my-lambda\n  name: my-service-binding\n  namespace: production\nspec:\n  instanceRef:\n    name: my-service-instance-name\nEOF\n```\n\n```\ncat <<EOF | kubectl apply -f -\napiVersion: servicecatalog.kyma-project.io/v1alpha1\nkind: ServiceBindingUsage\nmetadata:\n  labels:\n    Function: my-lambda\n    ServiceBinding: my-service-binding\n  name: my-service-binding\n  namespace: production\nspec:\n  serviceBindingRef:\n    name: my-service-binding\n  usedBy:\n    kind: function\n    name: my-lambda\nEOF\n```\n\n6. To expose the lambda function outside the cluster create an Api custom resource:\n```\ncat <<EOF | kubectl apply -f -\napiVersion: gateway.kyma-project.io/v1alpha2\nkind: Api\nmetadata:\n  labels:\n    function: my-lambda\n  name: my-lambda\n  namespace: production\nspec:\n  authentication: []\n  hostname: my-lambda-production.{CLUSTER_DOMAIN}\n  service:\n    name: my-lambda\n    port: 8080\nEOF\n```\n\n7. To verify that everything was setup correctly you can now call the lambda through https:\n  - On a cluster\n    ```\n    curl https://my-lambda-production.{CLUSTER_DOMAIN}/ -k\n    ```\n  - On a local deployment:\n    ```\n    curl https://my-lambda-production.kyma.local/ -k\n    ```\n\nA successful response returns a UUID generated by `httpbin.org`:\n```json\n{\n  \"uuid\": \"d44cc373-b26e-4a36-9890-6418d131a285\"\n}\n```\n","type":"Tutorials"},{"order":"08-07-application-mapping","title":"Bind an Application to a Namespace","source":"\nThis guide shows you how to bind an Application (App) to a Namespace in Kyma. To execute the binding, create an ApplicationMapping custom resource in the cluster. Follow the instructions to bind your App to the `production` Namespace.\n\n## Prerequisites\n\nTo complete this guide, your cluster must have at least one App created.\n\n## Steps\n\n1. List all Apps bound to the `production` Namespace:\n  ```\n  kubectl get em -n production\n  ```\n\n2. Bind an App to a Namespace. Run this command to create an ApplicationMapping custom resource and apply it to the cluster:\n\n  ```\n  cat <<EOF | kubectl apply -f -\n  apiVersion: applicationconnector.kyma-project.io/v1alpha1\n  kind: ApplicationMapping\n  metadata:\n    name: {NAME_OF_APP_TO_BIND}\n    namespace: production\n  EOF\n  ```\n\n3. Check if the operation is successful. List all Namespaces to which your App is bound:\n  ```\n  kubectl get em --all-namespaces -o jsonpath='{range .items[?(@.metadata.name==\"{NAME_OF_YOUR_APP}\")]}{@.metadata.namespace}{\"\"}{end}'\n  ```\n","type":"Tutorials"},{"order":"08-08-renew-client-cert","title":"Renew the client certificate","source":"\nBy default, the client certificate you generate when you connect an external solution to Kyma is valid for 92 days. Follow this tutorial to renew the client certificate.\n\n>**NOTE:** You can only renew client certificates that are still valid. If your client certificate is expired or revoked, you must generate a new one.\n\n1. To renew the client certificate, use the same certificate subject that matches the subject of your current certificate. To check the certificate subject, run:\n  ```\n  openssl x509 -noout -subject -in {PATH_TO_OLD_CRT}\n  ```\n\n2. Generate a new CSR using the certificate subject you got in the previous step. Run:\n  ```\n  openssl req -new -sha256 -out renewal.csr -key {PATH_TO_KEY} -subj \"{SUBJECT}\"\n  ```\n\nSend a request to the Connector Service to renew the certificate:\n\n  ```\n  curl -X POST https://gateway.{DOMAIN}/v1/applications/certificates/renewals -d '{\"csr\":\"BASE64_ENCODED_CSR\"}' -k --cert {PATH_TO_OLD_CRT} --key {PATH_TO_KEY}\n  ```\n\nA successful call returns a renewed client certificate:\n```\n{\n    \"crt\":\"BASE64_ENCODED_CRT_CHAIN\",\n    \"clientCrt\":\"BASE64_ENCODED_CLIENT_CRT\",\n    \"caCrt\":\"BASE64_ENCODED_CA_CRT\"\n}\n```\n","type":"Tutorials"},{"order":"08-09-revoke-cert","title":"Revoke the client certificate","source":"\nYou can revoke a client certificate generated for your Application. Revocation prevents a certificate from being [renewed](#tutorials-renew-the-client-certificate). A revoked certificate, however, continues to be valid until it expires.\n\nTo revoke a client certificate, send a request to the `certificates/revocations` endpoint. Pass the certificate you want to revoke and a key that matches this certificate in the call. Run:\n    \n```bash\ncurl -X POST https://gateway.{CLUSTER_DOMAIN}/v1/applications/certificates/revocations --cert {CERT_TO_REVOKE} --key {CERT_TO_REVOKE_KEY} -k \n```\n\n## Revoke a certificate using SHA256 fingerprint\n\nIf you have admin access to the Kyma cluster, you can revoke client certificates by sending the SHA256 fingerprint of \na certificate to the internal `certificates/revocations` endpoint. Follow these steps: \n\n1. Convert the certificate from the `pem` format to the `der` format. Run:\n    ```bash\n    openssl x509 -in {CLIENT_CERT_FILE}.crt -outform der -out {CLIENT_CERT_DER_FILE}.der\n    ```\n2. Get the SHA256 fingerprint of the certificate. Run:\n    ```bash\n    shasum -a 256 {CLIENT_CERT_DER_FILE}.der\n    ```\n3. Revoke the certificate using the SHA256 fingerprint:\n    ```bash\n    curl -X POST http://connector-service-internal-api:8080/v1/applications/certificates/revocations -d '{hash: {SHA256_FINGERPRINT_OF_CERT_TO_REVOKE_}}'\n    ```\n","type":"Tutorials"},{"order":"08-10-rotate-root-ca","title":"Rotate the Root CA certificate and key","source":"\nThe Central Connector Service uses the Root CA certificate to issue new certificates for runtimes and by the Nginx Ingress Controller to validate their identity.\n\nTwo different components use the Root CA certificate. As a result, the certificate is stored in two separate Secrets:\n  - The `connector-service-app-ca` Connector Service CA Secret responsible for signing certificate requests\n  - The `nginx-auth-ca` Nginx Ingress Secret responsible for security in the Connector Service API\n\nKeeping both Secrets up-to-date is vital for the security of your implementation as it guarantees that the Connector Service issues proper certificates and no unregistered applications can access its API.\n\nThe Root CA certificate has a set expiration date and must be renewed periodically to prevent its expiration. You must also renew the Root CA certificate and key every time they are compromised.\n\nThis tutorial describes the procedure you must follow for these scenarios:\n  - Rotating a soon-to-expire Root CA certificate\n  - Rotating a compromised Root CA certificate\n  - Rotating a compromised Root CA key\n\n## Rotating a soon-to-expire CA certificate\n\nTo successfully rotate a soon-to-expire CA certificate, replace it with a new certificate in both the Connector Service CA Secret and the Nginx Ingress Secret. Follow these steps to replace the old certificate in both Secrets:\n\n1. Get the existing Root CA key. Fetch it from the `connector-service-app-ca` Secret and save it to a `ca.key` file. Run:\n  ```\n  kubectl -n kyma-integration get secret connector-service-app-ca -o=jsonpath='{.data.ca\\.key}' | base64 --decode > ca.key\n  ```\n\n2. Generate a new certificate for the key you obtained and save it to a `new-ca.crt` file. Run:\n\n  ```\n  openssl req -new -key ca.key -x509 -sha256 -days {TTL_DAYS} -nodes -out new-ca.crt\n  ```\n\n>**NOTE:** Use the `-days` flag to set the TTL of the newly generated certificate.\n\n3. Encode the newly created certificate with base64:\n  ```\n  cat new-ca.crt | base64\n  ```\n\n4. Replace the old certificate in the Connector Service CA Secret. Edit the Secret and replace the `ca.crt` value with the new base64-encoded certificate. Run:\n  ```\n  kubectl -n kyma-integration edit secret connector-service-app-ca\n  ```\n\n5. Get the existing Nginx Ingress Secret. Fetch it from the `nginx-auth-ca` Secret and save it to a `old-ca.crt` file. Run:\n  ```\n  kubectl -n kyma-integration get secret nginx-auth-ca -o=jsonpath='{.data.ca\\.crt}' | base64 --decode > old-ca.crt\n  ```\n\n6. Merge the old Nginx certificate and the newly generated certificate into a single `nginx-ca.crt` file:\n  ```\n  cat old-ca.crt > nginx-ca.crt\n  cat new-ca.crt >> nginx-ca.crt\n  ```\n\n7. Encode the newly created `nginx-ca.crt` certificate file with base64:\n  ```\n  cat nginx-ca.crt | base64\n  ```\n\n8. Replace the old certificate in the Nginx Ingress Secret. Edit the Secret and replace the `ca.crt` value with the `nginx-ca.crt` base64-encoded certificate. Run:\n  ```\n  kubectl -n kyma-integration edit secret nginx-auth-ca\n  ```\n\n9. Renew the certificates in a runtime. To do that, create a CertificateRequest CR in the runtime in which you want to renew the certificates. Alternatively, wait for the certificates to expire in a given runtime. The system renews the certificates automatically using the information stored in the Secrets you updated.\n\n\n10. After the certificates are renewed in a runtime, remove the `nginx-auth-ca` Secret entry which contains the old certificate. First, encode the `new-ca.crt` file with base64:\n  ```\n  cat new-ca.crt | base64\n  ```\n\n11. Edit the Secret and replace the `ca.crt` value with the `new-ca.crt` base64-encoded certificate. Run:\n  ```\n  kubectl -n kyma-integration edit secret nginx-auth-ca\n  ```\n\n## Rotating a compromised Root CA certificate\n\n1. Get the existing Root CA key. Fetch it from the `connector-service-app-ca` Secret and save it to a `ca.key` file. Run:\n  ```\n  kubectl -n kyma-integration get secret connector-service-app-ca -o=jsonpath='{.data.ca\\.key}' | base64 --decode > ca.key\n  ```\n\n2. Generate a new certificate for the key you obtained and save it to a `new-ca.crt` file. Run:\n\n  ```\n  openssl req -new -key ca.key -x509 -sha256 -days {TTL_DAYS} -nodes -out new-ca.crt\n  ```\n\n>**NOTE:** Use the `-days` flag to set the TTL of the newly generated certificate.\n\n3. Encode the newly created certificate with base64:\n  ```\n  cat new-ca.crt | base64\n  ```\n\n4. Replace the old certificate in the Connector Service CA Secret. Edit the Secret and replace `ca.crt` value with the new base64-encoded certificate. Run:\n  ```\n  kubectl -n kyma-integration edit secret connector-service-app-ca\n  ```\n\n5. Replace the old certificate in the Nginx Ingress Secret. Edit the Secret and replace the `ca.crt` value with the new base64-encoded certificate. Run:\n  ```\n  kubectl -n kyma-integration edit secret nginx-auth-ca\n  ```\n\n6. Renew the certificates in a runtime. To do that, create a CertificateRequest CR in the runtime in which you want to renew the certificates.\n\n## Rotating a compromised root CA key\n\n1. Generate a new, RSA-encoded root CA key and save to a `new-ca.key` file:\n  ```\n  openssl genrsa -out new-ca.key 2048\n  ```\n\n2. Generate a new certificate using the key you generated and save it to a `new-ca.crt` file. Run:\n\n  ```\n  openssl req -new -key ca.key -x509 -sha256 -days {EXPIRATION_DAYS} -nodes -out new-ca.crt\n  ```\n\n>**NOTE:** Use the `-days` flag to set the TTL of the newly generated certificate.\n\n3. Encode the newly created certificate and key with base64:\n  ```\n  cat new-ca.key | base64\n  ```\n  ```\n  cat new-ca.crt | base64\n  ```\n\n4. Replace the old certificate and key in the Connector Service CA Secret. Edit the Secret and replace the `ca.crt` and `ca.key` values with the new base64-encoded certificate and key respectively. Run:\n  ```\n  kubectl -n kyma-integration edit secret connector-service-app-ca\n  ```\n\n5. Replace the old certificate in the Nginx Ingress Secret. Edit the Secret and replace the `ca.crt` value with the new base64-encoded certificate. Run:\n  ```\n  kubectl -n kyma-integration edit secret nginx-auth-ca\n  ```\n\n6. Renew the certificates in a runtime. To do that, create a CertificateRequest CR in the runtime in which you want to renew the certificates.\n","type":"Tutorials"},{"order":"09-01-connector-service","title":"Connector Service","source":"\nThe Connector Service exposes two separate APIs:\n\n- An internal API available in the Kyma cluster used to initiate certificate generation.\n- An external API exposed through Ingress used to finalize certificate generation.\n\nFind the specification of both of these APIs [here](./assets/connectorapi.yaml).\n\nAlternatively, get the API specification directly from the Connector Service:\n```\nhttps://connector-service.{CLUSTER_DOMAIN}/v1/api.yaml\n```\nRun this command to access the API specification on a local Kyma deployment:\n```\ncurl https://connector-service.kyma.local/v1/api.yaml\n```\n","type":"API"},{"order":"09-02-metadata-service","title":"Application Registry","source":"\nYou can get the API specification of the Application Registry for a given version of the service using this command:\n```\ncurl https://gateway.{CLUSTER_DOMAIN}/{APP_NAME}/v1/metadata/api.yaml\n```\n\nTo access the API specification of the Application Registry locally, provide the NodePort of the `application-connector-ingress-nginx-ingress-controller`.\n\nTo get the NodePort, run this command:\n\n```\nkubectl -n kyma-system get svc application-connector-ingress-nginx-ingress-controller -o 'jsonpath={.spec.ports[?(@.port==443)].nodePort}'\n```\n\nTo access the specification, run:\n\n```\ncurl https://gateway.kyma.local:{NODE_PORT}/{APP_NAME}/v1/metadata/api.yaml\n```\n","type":"API"},{"order":"09-03-event-service","title":"Event Service","source":"\n\n\nThe Event Service provides an endpoint for fetching subscribed Events for the application. To fetch all of them, make a call:\n\n```\ncurl https://gateway.{CLUSTER_DOMAIN}/{APP_NAME}/v1/events/subscribed -k --cert {APP_CERT} --key {APP_CERTS_KEY}\n```\n\nTo get all events locally, provide the NodePort of `application-connector-ingress-nginx-ingress-controller`.\n                  \nTo get the NodePort, run this command:\n                  \n ```\n kubectl -n kyma-system get svc application-connector-ingress-nginx-ingress-controller -o 'jsonpath={.spec.ports[?(@.port==443)].nodePort}'\n ```\n \n To fetch the Events, run this command:\n ```\n curl https://gateway.kyma.local:{NODE_PORT}/{APP_NAME}/v1/events/subscribed -k --cert {APP_CERT} --key {APP_CERTS_KEY}\n ```\n \n The successful call returns a list of all active Events for the application.\n \n>**TIP:** For details on the Event Service API specification, see [this file](./assets/eventsapi.yaml).\n","type":"API"}]},"navigation":{"topics":[{"id":"kyma","contentType":"root","sections":[{"topicType":"Overview","name":"Overview","anchor":"overview","titles":[{"name":"In a nutshell","anchor":"in-a-nutshell"},{"name":"Main features","anchor":"main-features"},{"name":"Technology stack","anchor":"technology-stack"},{"name":"Key components","anchor":"key-components"},{"name":"Kyma and Knative - brothers in arms","anchor":"kyma-and-knative---brothers-in-arms"},{"name":"How to start","anchor":"how-to-start"}]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Components","anchor":"components"},{"name":"Namespaces","anchor":"namespaces"},{"name":"Testing Kyma","anchor":"testing-kyma"},{"name":"Charts","anchor":"charts"},{"name":"Deploy with a private Docker registry","anchor":"deploy-with-a-private-docker-registry"}]},{"topicType":"Installation","name":"Installation","anchor":"installation","titles":[{"name":"Overview","anchor":"overview"},{"name":"Install Kyma locally","anchor":"install-kyma-locally"},{"name":"Install Kyma on a cluster","anchor":"install-kyma-on-a-cluster"},{"name":"Use your own domain","anchor":"use-your-own-domain"},{"name":"Use your own Kyma Installer image","anchor":"use-your-own-kyma-installer-image"},{"name":"Use Helm","anchor":"use-helm"},{"name":"Update Kyma","anchor":"update-kyma"},{"name":"Reinstall Kyma","anchor":"reinstall-kyma"},{"name":"Local installation scripts deep-dive","anchor":"local-installation-scripts-deep-dive"}]},{"topicType":"Configuration","name":"Configuration","anchor":"configuration","titles":[{"name":"Overview","anchor":"overview"},{"name":"Custom component installation","anchor":"custom-component-installation"},{"name":"Helm overrides for Kyma installation","anchor":"helm-overrides-for-kyma-installation"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"Installation","anchor":"installation"}]},{"topicType":"Tutorials","name":"Tutorials","anchor":"tutorials","titles":[{"name":"Sample service deployment on local","anchor":"sample-service-deployment-on-local"},{"name":"Sample service deployment on a cluster","anchor":"sample-service-deployment-on-a-cluster"},{"name":"Develop a service locally without using Docker","anchor":"develop-a-service-locally-without-using-docker"},{"name":"Publish a service Docker image and deploy it to Kyma","anchor":"publish-a-service-docker-image-and-deploy-it-to-kyma"}]},{"topicType":"Examples","name":"Examples","anchor":"examples","titles":[{"name":"Kyma features and concepts in practice","anchor":"kyma-features-and-concepts-in-practice"}]}]},{"id":"security","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Kubeconfig generator","anchor":"kubeconfig-generator"},{"name":"GraphQL","anchor":"graphql"},{"name":"GraphQL request flow","anchor":"graphql-request-flow"},{"name":"TLS in Tiller","anchor":"tls-in-tiller"},{"name":"Roles in Kyma","anchor":"roles-in-kyma"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"Group","anchor":"group"},{"name":"IDPPreset","anchor":"idppreset"}]},{"topicType":"Tutorials","name":"Tutorials","anchor":"tutorials","titles":[{"name":"Update TLS certificate","anchor":"update-tls-certificate"},{"name":"Manage static users in Dex","anchor":"manage-static-users-in-dex"},{"name":"Add an Identity Provider to Dex","anchor":"add-an-identity-provider-to-dex"}]}]},{"id":"service-catalog","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Resources","anchor":"resources"},{"name":"Provisioning and binding","anchor":"provisioning-and-binding"},{"name":"Service Catalog backup and restore","anchor":"service-catalog-backup-and-restore"},{"name":"Experimental features","anchor":"experimental-features"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"ServiceBindingUsage","anchor":"servicebindingusage"},{"name":"UsageKind","anchor":"usagekind"}]},{"topicType":null,"name":"CLI reference","anchor":"cli-reference","titles":[]},{"topicType":"Tutorials","name":"Tutorials","anchor":"tutorials","titles":[{"name":"Register a broker in the Service Catalog","anchor":"register-a-broker-in-the-service-catalog"}]},{"topicType":"UI Contracts","name":"UI Contracts","anchor":"ui-contracts","titles":[{"name":"Overview","anchor":"overview"},{"name":"Catalog view","anchor":"catalog-view"},{"name":"Instances View","anchor":"instances-view"}]},{"topicType":"Service Brokers","name":"Service Brokers","anchor":"service-brokers","titles":[{"name":"Overview","anchor":"overview"},{"name":"GCP Broker","anchor":"gcp-broker"},{"name":"Azure Service Broker","anchor":"azure-service-broker"},{"name":"AWS Service Broker","anchor":"aws-service-broker"}]}]},{"id":"helm-broker","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Create a bundle","anchor":"create-a-bundle"},{"name":"Bind bundles","anchor":"bind-bundles"},{"name":"Create a bundles repository","anchor":"create-a-bundles-repository"},{"name":"Service Classes documentation provided by bundles","anchor":"service-classes-documentation-provided-by-bundles"}]},{"topicType":null,"name":"Configuration","anchor":"configuration","titles":[]}]},{"id":"application-connector","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":"Architecture","name":"Architecture","anchor":"architecture","titles":[{"name":"Application Connector components","anchor":"application-connector-components"},{"name":"Connector Service","anchor":"connector-service"},{"name":"Application Gateway","anchor":"application-gateway"},{"name":"Application Broker","anchor":"application-broker"}]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Security","anchor":"security"},{"name":"Access the Application Connector on a local Kyma deployment","anchor":"access-the-application-connector-on-a-local-kyma-deployment"},{"name":"Consume applications through the Service Catalog","anchor":"consume-applications-through-the-service-catalog"},{"name":"Application Registry","anchor":"application-registry"},{"name":"Pass an access token in a request header","anchor":"pass-an-access-token-in-a-request-header"},{"name":"Payload size limits for registering APIs","anchor":"payload-size-limits-for-registering-apis"},{"name":"API registration in the Application Registry","anchor":"api-registration-in-the-application-registry"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"Application","anchor":"application"},{"name":"ApplicationMapping","anchor":"applicationmapping"},{"name":"EventActivation","anchor":"eventactivation"},{"name":"TokenRequest","anchor":"tokenrequest"}]},{"topicType":"Tutorials","name":"Tutorials","anchor":"tutorials","titles":[{"name":"Create a new Application","anchor":"create-a-new-application"},{"name":"Get the client certificate","anchor":"get-the-client-certificate"},{"name":"Register a service","anchor":"register-a-service"},{"name":"Register a secured API","anchor":"register-a-secured-api"},{"name":"Trigger a lambda with events","anchor":"trigger-a-lambda-with-events"},{"name":"Call a registered external service from Kyma","anchor":"call-a-registered-external-service-from-kyma"},{"name":"Bind an Application to a Namespace","anchor":"bind-an-application-to-a-namespace"},{"name":"Renew the client certificate","anchor":"renew-the-client-certificate"},{"name":"Revoke the client certificate","anchor":"revoke-the-client-certificate"},{"name":"Rotate the Root CA certificate and key","anchor":"rotate-the-root-ca-certificate-and-key"}]},{"topicType":"API","name":"API","anchor":"api","titles":[{"name":"Connector Service","anchor":"connector-service"},{"name":"Application Registry","anchor":"application-registry"},{"name":"Event Service","anchor":"event-service"}]}]},{"id":"event-bus","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Basic concepts","anchor":"basic-concepts"},{"name":"Event flow requirements","anchor":"event-flow-requirements"},{"name":"Service Programming Model","anchor":"service-programming-model"},{"name":"Troubleshooting","anchor":"troubleshooting"},{"name":"Subscription updates","anchor":"subscription-updates"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"Subscription","anchor":"subscription"}]},{"topicType":null,"name":"CLI reference","anchor":"cli-reference","titles":[]}]},{"id":"service-mesh","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Sidecar Proxy Injection","anchor":"sidecar-proxy-injection"},{"name":"Istio patch","anchor":"istio-patch"},{"name":"Istio RBAC configuration","anchor":"istio-rbac-configuration"}]}]},{"id":"serverless","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Custom Resources","anchor":"custom-resources"},{"name":"Managing Lambdas","anchor":"managing-lambdas"},{"name":"The Node.js Runtime","anchor":"the-node.js-runtime"}]},{"topicType":null,"name":"CLI reference","anchor":"cli-reference","titles":[]}]},{"id":"monitoring","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Tutorials","name":"Tutorials","anchor":"tutorials","titles":[{"name":"Expose custom metrics in Kyma","anchor":"expose-custom-metrics-in-kyma"}]}]},{"id":"tracing","contentType":"components","sections":[{"topicType":"Overview","name":"Overview","anchor":"overview","titles":[{"name":"Overview","anchor":"overview"}]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Benefits of distributed tracing","anchor":"benefits-of-distributed-tracing"},{"name":"Jaeger","anchor":"jaeger"},{"name":"Propagate HTTP headers","anchor":"propagate-http-headers"},{"name":"Compare traces","anchor":"compare-traces"}]}]},{"id":"api-gateway","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Security","anchor":"security"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"Api","anchor":"api"}]}]},{"id":"logging","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Access logs","anchor":"access-logs"},{"name":"Storage configuration","anchor":"storage-configuration"}]}]},{"id":"backup","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Configuration","anchor":"configuration"},{"name":"Back up a Kyma cluster","anchor":"back-up-a-kyma-cluster"},{"name":"Restore a Kyma cluster","anchor":"restore-a-kyma-cluster"}]}]},{"id":"console","contentType":"components","sections":[{"topicType":"Overview","name":"Overview","anchor":"overview","titles":[{"name":"Overview","anchor":"overview"}]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"UI extensibility","anchor":"ui-extensibility"},{"name":"Console Backend Service","anchor":"console-backend-service"},{"name":"Security guidelines for MicroFrontend and ClusterMicroFrontend CRs","anchor":"security-guidelines-for-microfrontend-and-clustermicrofrontend-crs"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"MicroFrontend","anchor":"microfrontend"},{"name":"ClusterMicroFrontend","anchor":"clustermicrofrontend"},{"name":"BackendModule","anchor":"backendmodule"}]}]},{"id":"asset-store","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Asset custom resource lifecycle","anchor":"asset-custom-resource-lifecycle"},{"name":"Bucket custom resource lifecycle","anchor":"bucket-custom-resource-lifecycle"},{"name":"Minio and Minio Gateway","anchor":"minio-and-minio-gateway"},{"name":"Asset Metadata Service","anchor":"asset-metadata-service"},{"name":"Asset Upload Service","anchor":"asset-upload-service"}]},{"topicType":"Configuration","name":"Configuration","anchor":"configuration","titles":[{"name":"Asset Store chart","anchor":"asset-store-chart"},{"name":"Asset Store Metadata Service sub-chart","anchor":"asset-store-metadata-service-sub-chart"},{"name":"Asset Store Controller Manager sub-chart","anchor":"asset-store-controller-manager-sub-chart"},{"name":"Asset Store Upload Service sub-chart","anchor":"asset-store-upload-service-sub-chart"},{"name":"Minio sub-chart","anchor":"minio-sub-chart"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"Asset","anchor":"asset"},{"name":"Bucket","anchor":"bucket"},{"name":"ClusterAsset","anchor":"clusterasset"},{"name":"ClusterBucket","anchor":"clusterbucket"}]},{"topicType":"Tutorials","name":"Tutorials","anchor":"tutorials","titles":[{"name":"Set Minio to the Google Cloud Storage Gateway mode","anchor":"set-minio-to-the-google-cloud-storage-gateway-mode"}]}]},{"id":"headless-cms","contentType":"components","sections":[{"topicType":null,"name":"Overview","anchor":"overview","titles":[]},{"topicType":null,"name":"Architecture","anchor":"architecture","titles":[]},{"topicType":"Details","name":"Details","anchor":"details","titles":[{"name":"Headless CMS in the Console","anchor":"headless-cms-in-the-console"},{"name":"DocsTopic custom resource lifecycle","anchor":"docstopic-custom-resource-lifecycle"}]},{"topicType":"Custom Resource","name":"Custom Resource","anchor":"custom-resource","titles":[{"name":"DocsTopic","anchor":"docstopic"},{"name":"ClusterDocsTopic","anchor":"clusterdocstopic"}]}]}]},"manifest":{"root":[{"displayName":"Kyma","id":"kyma"}],"components":[{"displayName":"Security","id":"security"},{"displayName":"Service Catalog","id":"service-catalog"},{"displayName":"Helm Broker","id":"helm-broker"},{"displayName":"Application Connector","id":"application-connector"},{"displayName":"Event Bus","id":"event-bus"},{"displayName":"Service Mesh","id":"service-mesh"},{"displayName":"Serverless","id":"serverless"},{"displayName":"Monitoring","id":"monitoring"},{"displayName":"Tracing","id":"tracing"},{"displayName":"API Gateway","id":"api-gateway"},{"displayName":"Logging","id":"logging"},{"displayName":"Backup","id":"backup"},{"displayName":"Console","id":"console"},{"displayName":"Asset Store","id":"asset-store"},{"displayName":"Headless CMS","id":"headless-cms"}]},"assetsPath":"/assets/docs/1.1/application-connector/docs/assets/","locale":"en"}}